---
layout: post
title:  "7. 快速排序"
date:   2020-05-28 08:04:01 +0800
categories: 数据结构与算法
tag: 算法导论
---

* content
{:toc}


****

> **未经许可，严禁任何形式的转载！**

****

**参考**

- 《算法导论 第三版 第七章》


****

> **快速排序最坏情况下，运行时间为 $$O(n^2)$$，但是其平均性能很好，期望时间复杂度为 $$\Theta(n \lg n)$$，且常系数很小。同时，其为原值排序，因此是实际排序应用中最好的选择！**：

# 快速排序

## 基本原理

快速排序也用到了**分而治之**的思想：

1. **分解**：将原数组 $$A[p...r]$$ 分解为两子数组 $$A[p, q-1], A[q+1, r]$$，其中 $$A[p, q-1]$$ 中的元素全部不大于 $$A[q]$$，$$A[q+1, r]$$ 中的元素全部不小于 $$A[q]$$。
2. **求解**：递归调用，分别求解子问题
3. **合并**：**原址排序**，无需合并

> **算法的核心在于求解部分。基本思路就是，取数组最右侧的值作为参考值，遍历数组。遍历过程中，可将小于参考值的数据往左交换，并通过一个指针记录最新比参考值小的位置。**

<div style="text-align:center">
<img src="/images/quickSort.gif" width="90%">
</div><br>

## 源码实现

```c++
void quick_sort(int * A, int left, int right){
    if(left < right){
        int q = quick_partion(A, left, right);

        quick_sort(A, left, q-1);
        quick_sort(A, q+1, right);
    }
}

int quick_partion(int* A, int p, int r) {
    int compare = A[r];   // 参考值
    int p_ind = p - 1;    // 划分点，左边全部不大于参考值

    for (int i = p; i < r; i++) { // 遍历每个元素
        if (A[i] <= compare) {   // 转移小于参考值的数据到左侧
            p_ind += 1;

            int tmp = A[p_ind];
            A[p_ind] = A[i];
            A[i] = tmp;
        }
    }

    int tmp = A[p_ind + 1];
    A[p_ind + 1] = A[r];
    A[r] = tmp;

    return (p_ind + 1);
}
```

## 时间复杂度分析

### 最坏情况

划分操作时间复杂度为 $$\Theta(n)$$。最坏情况下，每次两个子数组长度分别为 $$n-1$$ 和 $$0$$，此时时间复杂度为：

$$
T(n) = T(n-1) + T(0) + \Theta(n) = T(n-1) + \Theta(n) = \Theta(n^2)
$$

### 最好情况

最好情况下，两个子问题规模均不大于 $$n/2$$，此时时间复杂度为：

$$
T(n) = 2T(n/2) + \Theta(n) = \Theta(n \lg n)
$$

### 平衡的划分

**快速排序的平均运行时间更接近于其最好情况，而非最坏。**

假设按照 $$9:1$$ 进行划分，则：

$$
T(n) = T(9n/10) + T(n/10) + cn
$$

可以绘制二叉树求解运行时间，可得树的深度为 $$\log_{10/9} n = \Theta(\lg n)$$，因此总时间为 $$\Theta(n \lg n)$$。

## 快速排序的随机化版本

**在讨论快速排序的平均性能时，我们的前提假设是输入数据的排列是等概率的，但实际情况并不一定成立！因此可以使用随机算法，是的对于任意输入，均具有最好的期望性能。**

**此时，我们不在选定最右元素进行比较，而是随机选定一个元素，将其转移至最右，其余与标准快速排序相同。**